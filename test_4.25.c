/*
在计算机系统中，数值一律用补码来表示和存储，因为使用补码可以将符号位和数值域统一处理
同时，加减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转化，其运算过程是相同的，不需要额外的硬件
例:1 + (-1)
1的原码：00000000000000000000000000000001
-1的原码：10000000000000000000000000000001
两者相加为：10000000000000000000000000000010 -- 结果为-2不符合逻辑
所以用补码计算
1的补码：00000000000000000000000000000001
-1的补码：11111111111111111111111111111111
两者相加为：100000000000000000000000000000000 -- 结果为0 -- 由于两个补码相加有32个0，首位的符号位溢出
*/

/*
大小端存储方式：
0x11 22 33 44存放于内存中
11为高位字节 44为最低位字节
11 22 33 44（正序存放）为大端字节序存放
低地址  -->  高地址/高地址  -->  低地址
大端：把一个数据的高位字节序的内容存放在低地址处，把低字节序的内容放在高地址处，即为大端存储（即地址从低到高存放的数据字节序从高到低，为反序）

44 33 22 11（倒序存放）为小端字节序存放
小端：把一个数据的高位字节序的内容存放在高地址处，把低字节序的内容放在低地址处，即为小端存储（即地址从低到高存放的数据字节序从低到高，为正序）
*/

/*
同时，对于char型的单个数据，因为只有1个字节，故没有大小端存储的说法，即没有存放顺序一说
但对于short型、float型，long型等的具有多个字节的数据类型，就有存放顺序一说，存在大小端存储
*/

#include<stdio.h>

void check(int a)
{
	if (*(char*)&a == 1)
		printf("小端");
	else
		printf("大端");
}

int main()
{
	int a = 1;
	check(a);
	return 0;
}